Макросы препроцессора - аналоги переменных, которые создаются директивами препроцессора. Они обрабатываются до компиляции на этапе препроцессинга. Их опасно использовать, так как баги искать максимально сложно.

#### #define - можно назвать какой-то кусок кода каким-то именем, и потом писать его имя в коде. И на место этого имени препроцессор подставит значение макроса. Все работает как val в Kotlin.
```
#define PI 3.14159

double area = 2 * PI * r * r;
```

То есть по факту макросы - это переменные, но мыы не можем изменить их значение или взять их адрес (как и val в kotlin)

#### #undef - отменяет объявление макроса в коде ниже. 

### макросы - аналоги функций
можем написать макрос с параметрами, который будет их обрабатывать - по сути это функция:
```
#define MAX(a, b) a>=b ? a : b
```

или макрос, меняющий местами 2 переменные:
```
#define SWAP(type, a, b) type tmp = a; a = b; b = tmp;

SWAP(int, num1, num2)
SWAP(float, num1, num2) //ошибка!
```
Ниже при двойном использовании SWAP будет ошибка, так как переменную tmp объявят в коде 2 раза. Можно заюзать statement expression.
#### statement expression (GNU расширение)
-создает область видимости внутри макроса, что позволит не бояться двойного объявления переменной tmp
```
#define SWAP(type, a, b) ({type tmp = a; a = b; b = tmp;})
```

#### decltype - чтобы не передавать тип аргументов в макрос
P.S. макросы можно пеисать в много строк
```
#define SWAP(a, b) ({ \
decltype(a) tmp = a; \
a = b; \
b = tmp; \
})
```