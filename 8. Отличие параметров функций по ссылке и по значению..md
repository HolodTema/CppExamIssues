### Передача по значению (by value)
Тогда переданный в функцию аргумент копируется. И внутри функции видоизменяется уже копия, что не приводит к изменению переданного объекта:

```
void square(int); //prototype of fun

int main() {
	int n = 4;
	std::cout << n << '\n'; //4

	square(n); 
	std::cout << n << '\n'; // 4
}

void square(int n) {
	n *=n;
}
```

При компиляции для параметров функции выделяются отдельные участки памяти, куда эти параметры копируются. Функция манипулирует копиями переданных аргументов. 
Передача параметров функции по значению удобна, когда параметры весят мало.
### Передача по ссылке (by reference)
Передается ссылка на объект, и тогда изменения объекта в функции повлияют на объект вне функции. 

```
void square(int &n) {
	n *= n;
}

int main() {
	int n = 4;
	std::cout << n; //4

	square(n);
	std::cout << n; //16 - object changed
}
```

Передача по ссылке удобна когда объект большой, и мы хотим избежать лишнего копирования данных в памяти. 
Но как уберечься от риска, что я передам объект по ссылке в какую-то функцию, а она
его исковеркает?
Можно передавать объект по константной ссылке - мы уверены, что внутри функции объект не изменится, но и не скопируется. 

### Неявные приведения типов при передаче по ссылке невозможны!
```
void square(int &n) {
	n *= n;
}

int main() {
	double n = 5.0;
	square(n); //error: implicit cast is impossible
}
```